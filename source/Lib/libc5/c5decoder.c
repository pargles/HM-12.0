/*************************************************************************/
/*									 */
/*	 Source code for use with See5/C5.0 Release 2.10		 */
/*	 -----------------------------------------------		 */
/*		       Copyright RuleQuest Research 2013		 */
/*									 */
/*	This code is provided "as is" without warranty of any kind,	 */
/*	either express or implied.  All use is at your own risk.	 */
/*									 */
/*************************************************************************/


/*************************************************************************/
/*									 */
/*	Sample program to demonstrate the use of See5/C5.0 classifiers	 */
/*	--------------------------------------------------------------	 */
/*									 */
/*	Compilation:							 */
/*									 */
/*	    Unix: use an ANSI C compiler such as gcc and include	 */
/*		  the math library, e.g. gcc sample.c -lm		 */
/*									 */
/*	    Windows: compile as a console application with symbol	 */
/*		  "WIN32" defined					 */
/*									 */
/*	This program accepts three command-line options:		 */
/*									 */
/*	    -f <filestem>   specify the application name (required)	 */
/*	    -r		    use rulesets instead of decision trees	 */
/*	    -R		    use rulesets and show rules used		 */
/*	    -x		    use a similar format as saved by the	 */
/*			    See5 cross-reference window			 */
/*									 */
/*	The program expects to find the following files:		 */
/*									 */
/*	    <filestem>.names (the application names file)		 */
/*									 */
/*	    <filestem>.rules or <filestem>.tree (the classifier	files	 */
/*		 generated by C5.0 or See5)			 	 */
/*									 */
/*	    <filestem>.costs (optional -- the  costs file)		 */
/*									 */
/*	    <filestem>.cases (with a format similar to a .data file, but */
/*		allowing classes to be given as '?' meaning 'unknown')	 */
/*									 */
/*	Please note: the names file must be exactly as it was when	 */
/*	the classifier was generated.					 */
/*									 */
/*	For each case in <filestem.cases>, the program prints the	 */
/*	given class and then the class predicted by the classifier	 */
/*	together with the confidence of the prediction.			 */
/*									 */
/*	Revised March 2013						 */
/*									 */
/*************************************************************************/

#include "libc5.h"
//#include "defns.h"
//#include "global.c"

char LineBuffer2[MAXLINEBUFFER], *LBp2 = LineBuffer2;

Boolean SuppressErrorMessagesDecoder=false;
#define XErrorDecoder(a,b,c)	if (! SuppressErrorMessagesDecoder) Error(a,b,c)

/*************************************************************************/
/*									 */
/*	Main                                                             */
/*									 */

/*************************************************************************/


int mainFunctionDecoder(int Argc, char *Argv[])
/*  ----  */ {
    FILE *F;
    DataRec Case;
    int CaseNo = 0, o, StartList, CurrentPosition;
    ClassNo Predict;

    /*  Process options  */

    while ((o = ProcessOption(Argc, Argv, "f+xrR"))) {
        switch (o) {
            case 'f': FileStem = OptArg;
                break;
            case '?': printf("    **Unrecognised option %s\n", Option);
                exit(1);
        }
    }

    /*  Read information on attribute names, values, and classes  */

    if (!(F = GetFile(".names", "r"))) Error(NOFILE, Fn, "");

    GetNames(F);

    /*  Set up the classification environment  */

    GCEnv = AllocZero(1, CEnvRec);

    GCEnv->ClassWt = Alloc(MaxClass + 1, double);
    GCEnv->Vote = Alloc(MaxClass + 1, float);

    /*  Read the appropriate classifier file.  Call CheckFile() to
        determine the number of trials, then allocate space for
        trees or rulesets  */


    CheckFile(".tree", false);
    Pruned = AllocZero(TRIALS + 1, Tree);

    ForEach(Trial, 0, TRIALS - 1) {
        Pruned[Trial] = GetTree(".tree");
    }


    /*  Close the classifier file and reset the file variable  */

    fclose(TRf);
    TRf = 0;

    /*  Set global default class for boosting  */

    Default = Pruned[0]->Leaf;

    /*  Now classify the cases in file <filestem>.cases.
        This has the same format as a .data file except that
        the class can be "?" to indicate that it is unknown.  */

    printf("Case\t\tGiven\t\tPredicted%s\n %s\t\tClass\t\tClass\n\n",
            (LabelAtt ? "ID" : "No"));

    StartList = 60;


    char buffer[] = "1098,7371,6671,6671,0,1,1,0.5,5.713115,6.713115,?";

    F = fmemopen(buffer, strlen(buffer), "r");

    //if ( ! (F = GetFile(".cases", "r")) ) Error(NOFILE, Fn, "");

    LineNo = 0;
    //todo how to cast char** to FILE or how to replace file by char
    while ((Case = c5DecoderGetDataRec(F, false))) {
        /*  For this case, find the class predicted by See5/C5.0 model  */

        Predict = ClassifyCase(Case, GCEnv);

        /*  Print either case label or number  */

        if (LabelAtt) {
            printf("%-15.15s ", (String) (IgnoredVals + SVal(Case, LabelAtt)));
        } else {
            printf("%4d\t\t", ++CaseNo);
        }

        /*  Print the result for this case in alternative formats  */

        printf("%-15.15s %-15.15s [%.2f]",
                ClassName[Class(Case)],
                ClassName[Predict], GCEnv->Confidence);
        CurrentPosition = 54;

        printf("\n");

        /*  Free the memory used by this case  */

        c5DecoderFreeLastCase(Case);
    }

    /*  Close the case file and free allocated memory  */

    fclose(F);
    FreeGlobals();

    return 0;
}

int loadTreeToMemory(int Argc, char *Argv[])
/*  ----  */ {
    FILE *F;

    FileStem = Argv[2];

    /*  Read information on attribute names, values, and classes  */

    if (!(F = GetFile(".names", "r"))) Error(NOFILE, Fn, "");

    GetNames(F);

    /*  Set up the classification environment  */

    GCEnv = AllocZero(1, CEnvRec);

    GCEnv->ClassWt = Alloc(MaxClass + 1, double);
    GCEnv->Vote = Alloc(MaxClass + 1, float);

    /*  Read the appropriate classifier file.  Call CheckFile() to
        determine the number of trials, then allocate space for
        trees or rulesets  */


    CheckFile(".tree", false);
    Pruned = AllocZero(TRIALS + 1, Tree);

    ForEach(Trial, 0, TRIALS - 1) {
        Pruned[Trial] = GetTree(".tree");
    }


    /*  Close the classifier file and reset the file variable  */

    fclose(TRf);
    TRf = 0;

    return 0;
}

GlobalValues getAllocatedValues(){
    
    GlobalValues *globalValues= AllocZero(1, GlobalValues);
    globalValues->globalPruned = Pruned;
    globalValues->globalGCEnv = GCEnv;
    globalValues->globalClassAtt = ClassAtt;
    globalValues->globalLabelAtt = LabelAtt;
    globalValues->globalCWtAtt = CWtAtt;
    globalValues->globalClassName = ClassName;
    globalValues->globalAttName = AttName;
    globalValues->globalAttValName = AttValName;
    globalValues->globalMaxAtt = MaxAtt;
    globalValues->globalMaxClass = MaxClass;
    globalValues->globalAttExIn = AttExIn;
    globalValues->globalLineNo = LineNo;
    globalValues->globalErrMsgs = ErrMsgs;
    globalValues->globalDelimiter = Delimiter;
    globalValues->globalTSBase = TSBase;
    globalValues->globalMaxAttVal = MaxAttVal;
    globalValues->globalClassThresh = ClassThresh;
    globalValues->globalSpecialStatus = SpecialStatus;
    globalValues->globalAttDef = AttDef;
    globalValues->globalSomeMiss = SomeMiss;
    globalValues->globalSomeNA = SomeNA;
    
    globalValues->globalIgnoredVals = IgnoredVals;
    globalValues->globalIValsSize = IValsSize;
    globalValues->globalIValsOffset = IValsOffset;
    
    globalValues->globalTrialPred = TrialPred;
    globalValues->globalMCost = MCost;
    globalValues->globalRuleSet = RuleSet;
   
    
    return *globalValues;
}

int splitCU(char attributes[], GlobalValues *globals) {

    FILE *F;
    DataRec Case;
    ClassNo Predict;
    int splitCu;

    GCEnv = globals->globalGCEnv;
    
    Pruned = globals->globalPruned;

    /*  Set global default class for boosting  */

    Default = Pruned[0]->Leaf;

    F = fmemopen(attributes, strlen(attributes), "r");

    Case = c5DecoderGetDataRec(F, false);

    Predict = ClassifyCase(Case, GCEnv);
    //printf("%s\n", ClassName[Predict]);

    //Predict = class number, 1..MaxClass 
    //String *ClassName -> char *String
    if (ClassName[Predict][0] == '1') {
        splitCu = 1;
    } else {
        splitCu = 0;
    }

    /*  Free the memory used by this case  */

    c5DecoderFreeLastCase(Case);

    /*  Close the case file and free allocated memory  */

    fclose(F);
    //no need to remove tree
    //FreeGlobals();
    return splitCu;
}

/*************************************************************************/
/*									 */
/*	Source code for use with See5/C5.0 Release 2.10			 */
/*	-----------------------------------------------			 */
/*		      Copyright RuleQuest Research 2013			 */
/*									 */
/*	This code is provided "as is" without warranty of any kind,	 */
/*	either express or implied.  All use is at your own risk.	 */
/*									 */
/*************************************************************************/


DataRec c5DecoderGetDataRec(FILE *Df, Boolean Train)
/*      ----------  */ {
    Attribute Att;
    char Name[1000], *EndName;
    int Dv;
    DataRec Dummy, DVec;
    ContValue Cv;
    Boolean FirstValue = true;


    if (ReadName(Df, Name, 1000, '\00')) {
        Dummy = AllocZero(MaxAtt + 2, AttValue);
        DVec = &Dummy[1];

        ForEach(Att, 1, MaxAtt) {
            if (AttDef[Att]) {
                DVec[Att] = EvaluateDef(AttDef[Att], DVec);

                if (Continuous(Att)) {
                    CheckValue(DVec, Att);
                }

                if (SomeMiss) {
                    SomeMiss[Att] |= Unknown(DVec, Att);
                    SomeNA[Att] |= NotApplic(DVec, Att);
                }

                continue;
            }

            /*  Get the attribute value if don't already have it  */

            if (!FirstValue && !ReadName(Df, Name, 1000, '\00')) {
                XErrorDecoder(HITEOF, AttName[Att], "");
                c5DecoderFreeLastCase(DVec);
                return Nil;
            }
            FirstValue = false;

            if (Exclude(Att)) {
                if (Att == LabelAtt) {
                    /*  Record the value as a string  */

                    SVal(DVec, Att) = StoreIVal(Name);
                }
            } else
                if (!strcmp(Name, "?")) {
                /*  Set marker to indicate missing value  */

                DVal(DVec, Att) = UNKNOWN;
                if (SomeMiss) SomeMiss[Att] = true;
            } else
                if (Att != ClassAtt && !strcmp(Name, "N/A")) {
                /*  Set marker to indicate not applicable  */

                DVal(DVec, Att) = NA;
                if (SomeNA) SomeNA[Att] = true;
            } else
                if (Discrete(Att)) {
                /*  Discrete attribute  */

                Dv = Which(Name, AttValName[Att], 1, MaxAttVal[Att]);
                if (!Dv) {
                    if (StatBit(Att, DISCRETE)) {
                        if (Train) {
                            /*  Add value to list  */

                            if (MaxAttVal[Att] >= (long) AttValName[Att][0]) {
                                XErrorDecoder(TOOMANYVALS, AttName[Att],
                                        (char *) AttValName[Att][0] - 1);
                                Dv = MaxAttVal[Att];
                            } else {
                                Dv = ++MaxAttVal[Att];
                                AttValName[Att][Dv] = strdup(Name);
                                AttValName[Att][Dv + 1] = "<other>"; /* no free */
                            }
                        } else {
                            /*  Set value to "<other>"  */

                            Dv = MaxAttVal[Att] + 1;
                        }
                    } else {
                        XErrorDecoder(BADATTVAL, AttName[Att], Name);
                        Dv = UNKNOWN;
                    }
                }
                DVal(DVec, Att) = Dv;
            } else {
                /*  Continuous value  */

                if (TStampVal(Att)) {
                    CVal(DVec, Att) = Cv = TStampToMins(Name);
                    if (Cv >= 1E9) /* long time in future */ {
                        XErrorDecoder(BADTSTMP, AttName[Att], Name);
                        DVal(DVec, Att) = UNKNOWN;
                    }
                } else
                    if (DateVal(Att)) {
                    CVal(DVec, Att) = Cv = DateToDay(Name);
                    if (Cv < 1) {
                        XErrorDecoder(BADDATE, AttName[Att], Name);
                        DVal(DVec, Att) = UNKNOWN;
                    }
                } else
                    if (TimeVal(Att)) {
                    CVal(DVec, Att) = Cv = TimeToSecs(Name);
                    if (Cv < 0) {
                        XErrorDecoder(BADTIME, AttName[Att], Name);
                        DVal(DVec, Att) = UNKNOWN;
                    }
                } else {
                    CVal(DVec, Att) = strtod(Name, &EndName);
                    if (EndName == Name || *EndName != '\0') {
                        XErrorDecoder(BADATTVAL, AttName[Att], Name);
                        DVal(DVec, Att) = UNKNOWN;
                    }
                }

                CheckValue(DVec, Att);
            }
        }

        if (ClassAtt) {
            if (Discrete(ClassAtt)) {
                Class(DVec) = XDVal(DVec, ClassAtt);
            } else
                if (Unknown(DVec, ClassAtt) || NotApplic(DVec, ClassAtt)) {
                Class(DVec) = 0;
            } else {
                /*  Find appropriate segment using class thresholds  */

                Cv = CVal(DVec, ClassAtt);

                for (Dv = 1; Dv < MaxClass && Cv > ClassThresh[Dv]; Dv++)
                    ;

                Class(DVec) = Dv;
            }
        } else {
            if (!ReadName(Df, Name, 1000, '\00')) {
                XErrorDecoder(HITEOF, Fn, "");
                c5DecoderFreeLastCase(DVec);
                return Nil;
            }

            Class(DVec) = Dv = Which(Name, ClassName, 1, MaxClass);
        }

        return DVec;
    } else {
        return Nil;
    }
}

/*************************************************************************/
/*									 */
/*	Read next char keeping track of line numbers			 */
/*									 */
/*************************************************************************/

void FollowAllBranchesCase(DataRec Case, Tree T, float Fraction, double *Prob,
        Boolean *AttUsed)
/*   -----------------  */ {
    DiscrValue v;

    ForEach(v, 1, T->Forks) {
        if (T->Branch[v]->Cases > Epsilon) {
            FindLeafCase(Case, T->Branch[v], T,
                    (Fraction * T->Branch[v]->Cases) / T->Cases,
                    Prob, AttUsed);
        }
    }
}


/*************************************************************************/
/*                                                              	 */
/*	Classify a case using the given subtree.			 */
/*                                                              	 */
/*************************************************************************/


void FindLeafCase(DataRec Case, Tree T, Tree PT, float Fraction, double *Prob, Boolean *AttUsed)
/*   --------  */ {
    DiscrValue v, Dv;
    ClassNo c;
    double NewFrac, BrWt[4];


    switch (T->NodeType) {
        case 0: /* leaf */

            LeafUpdate :

                    /*  Use parent node if effectively no cases at this node  */

            if (T->Cases < Epsilon) {
                T = PT;
            }

            /*  Update from all classes  */

            ForEach(c, 1, MaxClass) {
                Prob[c] += Fraction * T->ClassDist[c] / T->Cases;
            }

            Prob[0] += Fraction * T->Cases;

            return;

        case BrDiscr: /* test of discrete attribute */

            Dv = DVal(Case, T->Tested); /* > MaxAttVal if unknown */

            if (Dv <= T->Forks) /*  Make sure not new discrete value  */ {
                FindLeafCase(Case, T->Branch[Dv], T, Fraction, Prob, AttUsed);
            } else {
                FollowAllBranchesCase(Case, T, Fraction, Prob, AttUsed);
            }

            return;

        case BrThresh: /* test of continuous attribute */

            if (Unknown(Case, T->Tested)) {
                FollowAllBranchesCase(Case, T, Fraction, Prob, AttUsed);
            } else
                if (NotApplic(Case, T->Tested)) {
                FindLeafCase(Case, T->Branch[1], T, Fraction, Prob, AttUsed);
            } else {
                /*  Find weights for <= and > branches, interpolating if
                    erobabilistic thresholds are used  */

                BrWt[2] = Interpolate(T, CVal(Case, T->Tested));
                BrWt[3] = 1 - BrWt[2];

                ForEach(v, 2, 3) {
                    if ((NewFrac = Fraction * BrWt[v]) >= 1E-6) {
                        FindLeafCase(Case, T->Branch[v], T, NewFrac, Prob, AttUsed);
                    }
                }
            }

            return;

        case BrSubset: /* subset test on discrete attribute  */

            Dv = DVal(Case, T->Tested); /* > MaxAttVal if unknown */

            if (Dv <= MaxAttVal[T->Tested]) {

                ForEach(v, 1, T->Forks) {
                    if (In(Dv, T->Subset[v])) {
                        FindLeafCase(Case, T->Branch[v], T, Fraction, Prob, AttUsed);

                        return;
                    }
                }

                /* Value not found in any subset -- treat as leaf  */

                goto LeafUpdate;
            } else {
                FollowAllBranchesCase(Case, T, Fraction, Prob, AttUsed);
            }
    }
}

/*************************************************************************/
/*									 */
/*	Select the best class to return.  Take misclassification costs	 */
/*	into account if they are defined.				 */
/*									 */
/*************************************************************************/

//used

ClassNo SelectClassCase(ClassNo Default, Boolean UseCosts, double *Prob)
/*      -----------  */ {
    ClassNo c, BestClass;
    double ExpCost, BestCost = 1E10;

    BestClass = Default;

    if (UseCosts) {

        ForEach(c, 1, MaxClass) {
            if (!Prob[c]) continue;

            ExpCost = MisclassCost(Prob, c);

            if (ExpCost < BestCost) {
                BestClass = c;
                BestCost = ExpCost;
            }
        }
    } else {

        ForEach(c, 1, MaxClass) {
            if (Prob[c] > Prob[BestClass]) BestClass = c;
        }
    }

    return BestClass;
}



/*************************************************************************/
/*								   	 */
/*	Find total misclassification cost of choosing class C		 */
/*	for cases in LocalFreq[]					 */
/*								   	 */

/*************************************************************************/


double MisclassCost(double *LocalFreq, ClassNo C)
/*     ------------  */ {
    double ExpCost = 0;
    ClassNo c;

    ForEach(c, 1, MaxClass) {
        if (c != C) {
            ExpCost += LocalFreq[c] * MCost[C][c];
        }
    }

    return ExpCost;
}



/*************************************************************************/
/*								   	 */
/*	General classification routine					 */
/*								   	 */
/*************************************************************************/

ClassNo TreeClassifyCase(DataRec Case, Tree DecisionTree, CEnv E)
/*      ------------  */ {
    ClassNo c, C;
    double Prior;

    /*  Save total leaf count in E->ClassWt[0]  */

    ForEach(c, 0, MaxClass) {
        E->ClassWt[c] = 0;
    }

    FindLeafCase(Case, DecisionTree, Nil, 1.0, E->ClassWt, E->AttUsed);

    C = SelectClassCase(DecisionTree->Leaf, (Boolean) (MCost != Nil), E->ClassWt);

#if defined WIN32 || defined PREDICT

    ForEach(c, 1, MaxClass) {
        Prior = DecisionTree->ClassDist[c] / DecisionTree->Cases;
        E->ClassWt[c] =
                (E->ClassWt[0] * E->ClassWt[c] + Prior) / (E->ClassWt[0] + 1);
    }
    E->Confidence = E->ClassWt[C];
#else
    Prior = DecisionTree->ClassDist[C] / DecisionTree->Cases;
    E->Confidence =
            (E->ClassWt[0] * E->ClassWt[C] + Prior) / (E->ClassWt[0] + 1);
#endif

    return C;
}

ClassNo BoostClassifyCase(DataRec Case, int MaxTrial, CEnv E)
/*	-------------  */ {
    ClassNo c, Best;
    int t;
    double Total = 0;

    ForEach(c, 1, MaxClass) {
        E->Vote[c] = 0;
    }

    ForEach(t, 0, MaxTrial) {
        Best = TreeClassifyCase(Case, Pruned[t], E);

        E->Vote[Best] += E->Confidence;
        Total += E->Confidence;

    }

    /*  Copy normalised votes into E->ClassWt  */

    ForEach(c, 1, MaxClass) {
        E->ClassWt[c] = E->Vote[c] / Total;
    }

    Best = SelectClassCase(Default, false, E->ClassWt);

    E->Confidence = E->ClassWt[Best];

    return Best;
}

ClassNo ClassifyCase(DataRec Case, CEnv E)
/*      --------  */ {
    E->NRulesUsed = 0;

    return ( TRIALS > 1 ? BoostClassifyCase(Case, TRIALS - 1, E) : TreeClassifyCase(Case, Pruned[0], E));
}


/*************************************************************************/
/*									 */
/*	Deallocate the space used to perform classification		 */
/*									 */
/*************************************************************************/

void FreeGlobals()
/*   -----------  */ {
    /*  Free memory allocated for classifier  */

    if (RULES) {

        ForEach(Trial, 0, TRIALS - 1) {
            FreeRules(RuleSet[Trial]);
        }
        free(RuleSet);

        FreeUnlessNil(GCEnv->Active);
        FreeUnlessNil(GCEnv->RulesUsed);
        FreeUnlessNil(GCEnv->MostSpec);
    } else {

        ForEach(Trial, 0, TRIALS - 1) {
            FreeTree(Pruned[Trial]);
        }
        free(Pruned);
    }

    //FreeUnlessNil(PropVal);

    /*  Free memory allocated for cost matrix  */

    if (MCost) {
        FreeVector((void **) MCost, 1, MaxClass);
    }

    /*  Free memory for names etc  */

    FreeNames();
    FreeUnlessNil(IgnoredVals);

    free(GCEnv->ClassWt);
    free(GCEnv->Vote);
    free(GCEnv);
}

void c5DecoderFreeLastCase(DataRec DVec)
/*   ------------  */ {
    free(&DVec[-1]);
    IValsOffset = 0;
}
